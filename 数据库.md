## 第一章 绪论

### 1.1 数据库概述

1.数据

数据是数据库中存储的基本对象，描述事物的符号。

2.数据库

**数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。**数据库中 的数据按一定的数据模型组织，描述和存储，具有较小的冗余度，较高的数据独立性和易扩展性，并可为各种用户共享。三大特点：永久存储、有组织、可共享。

3.数据库管理系统

**DBMS是位于用户和操作系统之间的一层数据管理软件，是一个系统软件。**

**主要功能：**数据定义、数据组织、存储和管理、数据库的事务管理和运行管理、数据库的建立和维护功能、其他功能(通信功能、转换功能)

4.数据库系统

DBS由数据库、数据库管理系统、应用程序和数据库管理员组成的存储、管理、处理和维护数据的系统。

数据库系统的特点：

数据结构化、数据的共享性高、冗余度低且易扩展、数据独立性高(数据的物理存储改变、逻辑结构改变时用户程序可以不变)、数据由DBMS统一管理和控制(数据的安全性保护、数据的完整性保护、数据库恢复、并发控制)

### 1.2 数据模型

数据模型是对现实世界数据特征的抽象，**是数据库系统的核心和基础。**

根据模型应用的目的，可以将模型划分为两大类，概念模型（用于数据库设计）和逻辑模型（用于数据库管理系统的实现）+物理模型

**概念模型一些概念：**

实体：客观存在并可相互区别的事物，具体的人，事物

码：能唯一标识实体的属性集

实体型：用实体名和属性集合来抽象和刻画同类实体，例如，学生（学号，姓名）

**数据模型三要素：**

数据结构：描述数据库的组成对象以及对象之间的联系，系统静态特性的描述

数据操作：指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则，系统动态特性的描述。

数据的完整性约束条件：一组完整性规则，必须满足实体完整性和参照完整性，还有用户自定义完整性。

**常用的逻辑数据模型：**

1.层次模型（树形结构）

2.网状模型（图）

3.关系模型

4.面向对象数据模型、对象关系数据模型、半结构化数据模型

### 1.3 数据库系统的结构

模式是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及型的描述，不涉及具体的值。

**数据库的三级模式：**

模式：也称为逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。

外模式(视图)：数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图。

内模式：也称为存储模式，一个数据库只有一个内模式，它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。

**数据库的二级映像与数据独立性**

数据的独立性:不会因为系统数据存储结构和逻辑结构的改变影响应用程序。

1.外模式/模式映像

当模式改变的时候，由数据库的管理员对各个外模式/模式的映像做改变，可使外模式不改变，应用程序是根据外模式编写的，从而应用程序不用改变，保证了**数据与程序的逻辑独立性，简称数据的逻辑独立性。**

2.模式/内模式映像

当数据库的存储结构改变时，由数据库管理员对模式/内模式作相应改变，可以使模式保持不变，从而应用程序也可以不变，保证了**数据与程序的物理独立性，简称数据的物理独立性。**

### 1.4数据库系统的组成

硬件平台及数据库、软件、人员。

****

## 第二章 关系数据库

### 2.1 关系数据结构及形式化定义

1.域

域是一组具有相同数据类型的集合。

2.笛卡尔积

3.关系

**候选码：能够唯一标识一个元组，而其子集不能，则称该属性组为候选码。**

若一个关系有多个候选码，则选定其中一个为主码。

候选码的诸属性为主属性，不包含在任何在候选码中的属性称为非主属性。

**关系的性质：**

列是同质的，即每列中的分量是同一类型的数据，来自同一个域。

不同的列可以来自同一个域，不同的属性要给予不同的属性名。

列的顺序无所谓。

任何两个元组的候选码不能取相同的值。

行的顺序无所谓。

分量必须取原子值。

**关系模式：关系模式是型，关系是值。**

关系是关系模式在某一时刻的状态或内容，关系模式是静态的，稳定的，而关系是动态的，随时间不断变化的。

### 2.2 关系操作

查询操作的5种基本操作：选择、投影、并、差、笛卡尔积

关系操作的结果和对象都是集合。

### 2.4关系代数

1.集合运算符

并、交、差、笛卡尔积

2.专门的关系运算符

选择、投影、连接、除

## 第三章 关系数据库标准语言SQL

### 3.1 SQL概述

SQL集数据查询、数据操纵、数据定义、数据控制等功能于一体。

特点：

综合统一、高度非过程化、面向集合的操作方式、以同一种语法结构提供多种使用方式、语言简洁，易学易用。

外模式包括若干视图和部分基本表，模式包括若干基本表，内模式包括若干存储文件。

### 3.3 数据定义

```sql
#1.定义模式
create schema <模式名> authorization<用户名>;#如果未指定模式名，则默认为用户名
#2.删除模式
drop schema <模式名><cascade|restrict>#restrict表示该模式下无下属数据库对象才能执行drop语句，否则拒绝执行。
#3.定义基本表
create table <表名>(<列名><数据类型>[列级完整性约束],...[表级完整性约束]);
#4.修改表
alter table <表名>
[add [column] <列名><数据类型>[完整性约束]]
[add <表级完整性约束>]
[drop [column] <列名>[cascade|restrict]]
[drop constraint<完整性约束名>[cascade|restrict]]
[alter column <列名><数据类型>]
alter table add unique(Cname);#增加Cname不能重复
#5.删除基本表
drop table<表名>[cascade|restrict]
#6.建立索引(索引的目的是加快查询速度)
create [unique][cluster] index<索引名>on<表名>(<列名>);
drop index<索引名>

```

### 3.4 数据查询

```sql
#1.单表查询
select Sno from Student;#投影操作
select distinct Sno from Student;#去重
#查询满足条件的元组--where子句
#where子句常用的查询条件
比较:=,<,>!=
确定范围:between and ,not between and
确定集合:in、not in
字符匹配:like、not like,%代表任意长度的字符串,_代表任意单个字符,数据库字符集为ASCII时一个汉字需要两个_，当字符集为gbk时，则只要一个。
如果匹配的字符本身含有通配符%,_这时就需要escape '<换码字符>'
#like 'db\_%i__'escape '\';匹配以db_开头且倒数第三个字符为i的字符串
空值:is null、is not null,is不能用=代替
多重条件:and、or、not,and优先级比or高
#order by 
默认升序/asc，降序/desc,对于空值，按最大值处理，即升序时排在最后，降序时排在最前面。
#聚集函数
count([distinct|all]<列名>) 统计元组个数
sum() 统计一列值的总和
当聚集函数遇空值时,除count(*)外，都跳过空值而只处理非空值
聚集函数只能用于select子句和group by中的having子句
#group by
select子句只能出现分组属性、聚合函数，where子句中不能作用聚集函数作为条件表达式。
#2.连接查询
1.等值连接与非等值连接查询
连接查询的where子句中用来连接两个表的条件称为连接条件或连接谓词
[<表名1>].<列名1><比较运算符>[<表名2>].<列名2>
select Student.*,SC.* from Student,SC where Student.Sno=SC.Sno;
2.自身连接
select FIRST.Cno,Second.Cpno from Course FIRST,Course Second where First.Cpno=Second.Cno;
3.外连接
select Student.Sno,Sname,Cno,Grade from Student left outer join SC on(Student.Sno=SC.Sno);
#3.嵌套查询
一个select-from-where语句成为一个查询块，将一个查询块嵌套在另一个查询块的where子句或having子句中称为嵌套查询。子查询不能使用order by，order by 只能对最终查询结果排序。
1.带有in谓词的子查询
不相关子查询:
select Sno,Sname,Sdept from Student where Sdept in(select Sdept from Student where Sname='刘晨');
相关子查询:
select Sno,Cno from SC x where Grade>=(select avg(Grade)from SC y where x.Sno=y.Sno);
2.带ANY或ALL谓词的子查询
返回多值时要用ANY或ALL谓词修饰符
>ANY 大于子查询结果的某个值
>ALL 大于子查询结果的所有值
!=(<>)ANY 不等于子查询结果中的某个值
!=(<>)ALL 不等于子查询结果中的任何一个值
=ANY等价于in
<ANY等价于<MAX
<>ALL等价于not in
<ALL等价于<MIN
3.带exists谓词的子查询
EXISTS代表存在量词,带有exists谓词的子查询不返回任何数据，只产生逻辑真或假
查询所有选修了1号课程的学生姓名
selectta Sname from Student where exists(select * from SC Sno=Student.Sno and Cno='1');
a.查询选修了全部课程的学生姓名
sql中没有全称量词，但是可以把带有全称量词的谓词转换为等价的带有存在量词的谓词
选修了全部课程的学生名==>不存在没有没选修的课程
select Sname from Student where not exists(select * from Course where not exists(select * from SC where Sno=Student.Sno and Cno=Course.Cno));
b.查询至少选修了学生201215122选修的全部课程的学生号码
sql中无蕴涵逻辑运算，但是可以利用谓词演算将一个逻辑蕴涵的谓词等价转换为带有存在谓词
不存在这样的课程，学生2012选修了，而学生x没有选。
select Sno from SC SCX where not exists(select * from SC SCY where Sno='2012' and not exists(select * from SC where Cno=SCY.Cno and Sno=SCX.Sno));
4.集合查询
并操作:union、交操作:intersect、差操作:except
```

### 3.5 数据更新

```sql
1.插入数据
a.插入元组
insert into <表名>[属性列]values(常量);
b.插入子查询结果
insert into<表名>[属性列]子查询;
2.修改数据
一般格式:update <表名> set <列名>=<表达式>[where<条件>];
update Student set Sage=Sage+1;
3.删除数据
delete from<表名>[where<条件>];#删除表中满足where子句条件的所有元组，如果省略则删除所有数据，不是删除表的定义
```

### 3.7 视图

```sql
1.定义视图
create view <视图名>[列名] as <子查询> [with check option];#create view语句只是把视图的定义存入数据字典，并不执行select语句，只是在对视图查询时才从基本表中将数据查出。
create view v1 as select Sno,Sname,Sage from Student where Sdept='IS' with check option;#由于with check option，以后对视图进行insert、update、delete操作时，关系数据库会自动加上Sdept='IS'的条件。
带虚拟列(基本表中不存在的/Sbirth)的视图也称为带表达式的视图:
create view v1(Sno,Sname,Sbirth)
as select Sno,Sname,2021-Sage from Student;
如果修改基本表的结构，最好在修改基本表之后删除由该表导出的视图，再重建视图。
2.删除视图
drop view <视图名>[cascade];
3.查询视图
create view S_G(Sno,Gavg) as select Sno,AVG(Grade) from SC group by Sno;
select * from S_G where Gavg>=90;#错误，聚集函数不能用在where子句中
4.更新视图
不是所有视图都可以更新的，因为有些视图的更新不能唯一地有意义地转换成对相应基本表的修改。比如对平均成绩的修改。
```

视图的作用：简化用户的操作、使用户能够以多种角度看待同一数据、对重构数据库提供了一定程度的逻辑独立性、能够对机密数据提供安全保护、适当利用视图可以更清晰地表达查询。

## 第四章 数据库安全性

### 4.1数据库安全性概述

数据库安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改、破坏。

**不安全因素：**

1.非授权用户对数据库进行恶意存取和破坏

DBMS提供的安全措施有用户身份鉴别、存取控制和视图等技术。

2.数据库中重要或敏感信息泄露

强制存取控制、数据加密存储和加密传输、在安全性较高的部门还提供审计功能。

3.安全环境脆弱

加强计算机系统的安全性保证

**安全标准简介：TCSEC、CC**

TCSEC/TDI将系统划分为四个等级D、C、B、A，按照系统可靠或可信程度逐步增高，**其中C2为自主安全保护/DAC，B1为标记安全保护/MAC。**

### 4.2数据库安全性控制

1.用户身份鉴别

静态口令鉴别、动态口令鉴别、生物特征鉴别、智能卡鉴别

**2.存取控制**

数据库最重要的一点就是确保只授权给有资格的用户访问数据库的权限，同时令所有未被授权的人员无法接近数据。

存取控制机制主要包括**定义用户权限和合法权限检查**两部分。

**自主存取控制**

用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可以将拥有的权限转授给其他用户。

用户权限由数据库对象和操作类型组成，定义存取权限称为授权。

```sql
#授权
grant<权限>[,<权限>...]
on <对象类型><对象名>,[...]
to <用户>,[...] #public,即全体用户，或者指定一个/多个用户
[with grant option];#允许获得某权限的用户进行权限转授，不允许循环授权
#eg
grant select on table SC to U1 with grant option;
#回收权限
revoke<权限>[...]
on <对象类型><对象名>,[...]
from <用户>
[cascade|restrict]#级联删除
#数据库角色
create role r1;
grant select on table SC to r1;
grant r1 to U1;
#修改数据库角色
grant delete on table SC to r1;
revoke insert on table SC from r1;
```

**强制存取控制**

每一个数据库对象都被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取。

**在强制存取控制中，DBMS所管理的系统都分为主体和客体两类**，主体包括各用户、用户的各进程，客体包括受主体操纵的各个文件、基本表、视图，每一个实例指派一个敏感读标记，绝密TS，机密S，可信C,公开P。

**当某一用户以标记label注册进入系统时，系统要求他对任何客体 的存取控制必须遵守如下规则：**

1.仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体

2.仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体

违反规则2，可能把数据的密级从高往低流，造成数据的泄露。

强制存取控制是对数据本身进行密级标记，无论数据如何复制，标记与数据都是一个不可分的整体，只有符合密级标记的用户才可以操纵数据。

### 4.3 视图机制

可以为不同的用户定义不同的视图，把数据对象限制在一定的范围内，也就是说，通过视图机制把要保密的数据对无权存取的用户隐藏起来。

```sql
create view v1 as select * from SC;
grant select on v1 to U1;
grant all privileges on v1 to U2;#将所有权限都给u2
```

****

### 4.4 审计

C2以上数据库

审计功能把用户对数据库的所有操作自动记录下来放入审计日志，审计员可以利用审计日志监控数据库中的各种行为，重现导致数据库现有状况的一系列事件，找出非法存取数据的人，时间和内容等。

****

### 4.5数据加密

加密的思想：根据一定的算法将原始数据---明文转换为不可直接识别的格式---密文，从而使得不知道解密算法的人无法获知数据的内容。

1.存储加密

透明存储加密、非透明存储加密

2.传输加密

链路加密、端到端加密(只加密报文，不加密报头)

### 4.6 其他安全性保护

推理控制、隐蔽信道、数据隐私保护

****

## 第五章 数据库完整性

1.数据库的完整性是指数据的正确性和相容性，数据的正确性是指数据是符合现实世界语义、反映当前实际状况的，数据的相容性是指数据库同一对象在不同关系表中是符合逻辑的。

2.数据库的完整性是指数据的正确性、有效性、相容性，防止合法用户无意中造成的破坏。

**数据的完整性和安全性的联系：**

1.数据的完整性是为了防止数据库中出现不符合语义的数据，不正确的数据。

2.数据的安全性是保护数据库防止完整性恶意破坏和非法存取。

### 5.1实体完整性

```sql
#实体的完整性在create table中用primary key定义
#对单属性的码有两种说明方法：一种定义为列级约束条件，另一种是定义为表级约束条件，对多属性的说明只能采用表级约束条件。
create table sc(
Sno char(9) not null,
Cno char(4) not null,
grade smallint,
primary key(Sno,Cno)#只能在表级定义主码
);
```

**实体完整性检查和违约处理：**

1.检查主码是否唯一，如果不唯一则拒绝插入

2.检查主码各个属性是否为空，有一个为空就拒绝插入

**采用全表扫描法，或在主码上建立索引/B+树索引**

****

### 5.2 参照完整性

```sql
#在create table中用foreign key定义哪些列为外码，用references定义这些外码参照那些表的主码
create table sc(
    Sno char(9) primary key,
    Cno char(4) not null,
    Grade smallint,
    foreign key Sno references Student(Sno)
);
```

**检查和违约处理：**

1.拒绝执行（默认策略）

2.级联操作，包括级联删除、级联修改

3.设为空值

当参照表和被参照表操作违反了参照完整性，系统默认策略，如果想要系统使用其他策略，必须在创建参照表的时候显式说明。

```sql
create table sc(
    Sno char(9) primary key,
    Cno char(4) not null,
    Grade smallint,
    foreign key Sno references Student(Sno)
    on delete cascade #级联删除,
    on update no action #拒绝删除
);
```

****

### 5.3 用户自定义完整性

**不满足都拒绝执行**

**1.属性上的约束条件**

```sql
#列值非空
 not null
 #列值唯一
 unique
 #检查列值是否满足一个条件表达式
 check短语
 check(Ssex in('man','woman'))
 check(grade>=0 and grade<=100)
```

**2.元组上的约束**

```sql
#check短语定义元组上的约束条件
check(Ssex='woman' or Sname not like 'Ms.%')
#性别是女的元组都通过检查，性别为男，要通过检查名字不能以Ms.打头
```

****

### 5.4 完整性约束子句

**constraint子句用来对完整性约束条件命名，从而可以灵活增加、删除一个完整性约束条件**

```sql
#constraint <完整性约束条件名><完整性约束条件>
# 完整性约束条件包括:not null,unique,primary key,foreign key,check短语
create table Student(
    Sno numeric(6)
    constraint c1 check(Sno between 1 and 100)
);
# 修改表中的完整性限制，可以使用 alter table语句
alter table Student drop constraint c1;#删除c1约束
alter table add constraint c2 check(Sno between 9 and 10);#增加约束条件
```

****

### 5.6 断言

断言创建以后，任何断言中所涉及关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行。

```sql
#创建断言
create assertion <断言名><check子句>
create assertion as_db_sum
	check(60>=all(select count(*) fron SC group by Sno,TERM
    ));
#创建断言
drop assertion <断言名>;
```

****

### 5.7 触发器

**触发器：**使用户定义在关系表上的一类由事件驱动的特殊过程，一旦定义，触发器将被保存在数据库服务器中,**又叫事件-条件-动作规则**。

**关系：表、关系模型：数据库、关系模式：表的描述**

```sql
create trigger <触发器名> #每当触发事件发生时，该触发器被激活
{before|after}<触发事件>on<表名>#触发器激活的时间是在触发事件前或后
referencing new|old row as<变量>#referencing指出引用的变量
for each{row|statement} #定义触发器类型，指明动作体执行的频率
[when <触发条件>]<触发动作体> #仅当触发条件为真时才执行触发动作体
#触发事件：select、delete或update of<触发列>
#触发器类型：for each row：行级触发器、for each statement：语句级触发器
#如果触发动作执行失败，激发触发器的事件就会终止执行
create trigger SC_T #SC_T是触发器名字
after update of grade on SC # update of grade on SC是触发事件
referencing 
	oldrow as oldtuple
	newrow as newtuple
for each row #行级触发器，即每执行一次grade更新，下面的规则就执行一次
when(newtuple.grade>=1.1*oldtuple.grade) #触发条件，只有该条件为真时才执行
	insert into SC_U(Sno,Cno,OldGrade,NewGrade) values(oldtuple.Sno,oldtuple,oldtuple.Grade,newtuple.grade);
```

触发器的执行是由触发事件激活，由数据库服务器自动执行。同一个表上的多个触发器激活时遵循如下执行顺序：

1）执行该表上的before触发器（谁先创建谁先执行）

2）激活触发器的SQL语句

3）执行该表上的after触发器

删除触发器：

```sql
drop trigger <触发器名>on<表名>;
```



## 第六章 关系数据库理论

### 6.1 提出问题

**第一范式/1NF:**每个分量必须是不可分的数据项，关系的最基本条件

**插入异常：**应该插入的数据未被插入

**删除异常：**不应该被删除的数据被删除

一个好的模式应当不会发生插入异常、删除异常、更新异常、数据冗余尽可能少

### 6.2规范化

### 1.函数依赖

设R(U)是属性集U上的关系模式，X,Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上属性相等，而在Y上的属性不等，则称X函数确定Y或Y函数依赖于X，记作X→Y。

**函数依赖与属性之间的联系类型有关：**

1.若一个关系模式中，如果属性X与Y有1：1联系时，则X&larr;&rarr;Y

2.若在一个关系模式中，X与Y有1：m联系时，则Y&rarr;X

3.若在一个关系模式中，X与Y有n:m联系时，则X,Y之间无函数依赖关系。

**决定因素：**

若X&rarr;Y，则X称为这个函数依赖的决定属性组，也称为决定因素。

**完全函数依赖**

在R(U)中，如果X&rarr;Y,并且对于X的任何一个真子集X‘，都有X'&rarr;/Y,则Y对X完全函数依赖。

**传递函数依赖**

![image-20210623204351877](C:\Users\兰粑粑\AppData\Roaming\Typora\typora-user-images\image-20210623204351877.png)

### 2.码

**候选码**

设K为R<U,F>中的属性或属性组合，若U完全函数依赖于K，则K为R的候选码。

若候选码多于一个，则选定其中一个作为主码。

**主属性/非主属性**

包含在任何一个候选码中的属性称为主属性，不包含在任何一个候选码中的属性称为非主属性。

**外部码**

关系模式R中的属性或属性组X不是码，而是另外一个关系模式的码，则称X为R的外码。

### 3.2NF

**定义：**若R∈1NF，并且每一个非主属性完全函数依赖于任何一个候选码，则R∈2NF。

### 4.3NF

**定义:**

![image-20210623205735144](C:\Users\兰粑粑\AppData\Roaming\Typora\typora-user-images\image-20210623205735144.png)

由定义可证：若R∈3NF，则每一个非主属性既不传递依赖于码，也不部分依赖于码。

### 5.BCNF

**定义：**关系模式R<U,F>中，每一个决定因素中都含有码，则R<U,F>∈BCNF。

**结论：**

a.所有非主属性对每一个码都是完全函数依赖。

b.所有主属性对每一个不包含它的码也是完全函数依赖。

c.没有任何属性完全函数依赖于非码的任何一组属性。

**BCNF排除了任何属性对码的传递依赖和部分依赖。**

**在关系数据库中，任何二元关系模式的最高范式必定是BCNF**

如果一个关系数据库中所有关系模式都属于BCNF，那么在函数依赖的范畴内，已经实现了模式的彻底分解，消除了产生插入异常和删除异常的根源，数据冗余也减少到极小的程度。

### 6.多值依赖

设R(U)是属性集U上的一个关系模式，X,Y,Z是U的子集，并且Z=U-X-Y，关系模式R(U)中多值依赖X&rarr;&rarr;Y成立，当且仅当对R(U)中的任一关系r，给定的一对(x,z)值，有一组Y的值，这组值仅仅决定于x值而与z值无关。

**等价形式化定义**：交换两个元组在Y属性上的值所得新元组仍在关系中。

若X&rarr;&rarr;Y,而Z为空，则称X&rarr;&rarr;Y为平凡的多值依赖，否则为非平凡的多值依赖。

**4NF**

![image-20210623213833516](C:\Users\兰粑粑\AppData\Roaming\Typora\typora-user-images\image-20210623213833516.png)

1》不允许有非平凡且非函数依赖的多值依赖

2》允许函数依赖(是非平凡多值依赖的特例)

3》允许平凡的多值依赖

**多值依赖性质：**

1》多值依赖具有对称性

若X&rarr;&rarr;Y,则X&rarr;&rarr;Z,其中Z=U-X-Y.

每个保管员保管所有商品，同时每种商品被所有保管员保管。

****

## 第七章 数据库设计

### 7.1 数据库设计概述

数据库设计是指对于一个给定的应用环境，构造优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，包括**信息管理要求**和**数据操作要求**。

数据库设计的特点：数据库建设的基本规律---三分技术、七分管理、十二分基础数据，数据库设计应该和应用系统设计相结合。

数据库的设计方法：新奥尔良方法，基于E-R模型的设计方法、3NF的设计方法、面向对象的数据库设计方法、统一建模语言方法。

**数据库设计的基本步骤：需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施、数据库运行和维护。**

各阶段的数据设计描述：

需求分析：数据字典、数据项、数据结构、数据流、数据存储的描述。

概念结构设计：E-R图，形成独立于机器特点和各数据库管理系统产品的概念模式

逻辑结构设计：E-R图->关系模型，**形成外模式**

物理结构设计：存储安排、存取方法选择、存取路径建立，建立索引，**形成内模式**。

数据库实施：建库、装入数据、试运行

数据库运行与维护：性能检测、转储/恢复、数据库重组和重构

****

### 7.2 需求分析

任务：得到数据字典描述的数据需求、得到数据流图描述的处理需求。

需求分析的方法：结构化分析/SA，采用自顶向下、逐层分解的方式分析系统。

数据字典包括数据项、数据结构、数据流、数据存储、处理过程。

****

### 7.3 概念结构设计

**1.实体之间的联系**

a.两个实体型之间的联系

一对一联系：一个班一个班长、一个班长只在一个班中任职。

一对多联系：一个班多个学生，一个学生只在一个班。

多对多联系：一门课多个学生选，一个学生可同时选多门课。

b.两个以上的实体型之间的联系

课程、教师、参考书

一门课由若干老师教，使用若干参考书，每一个教师只教授一门课程，一本参考书只供一门课使用。1：n：m

c.单个实体型内的联系

职工实体型：某一职工领导若干名职工，一个职工仅被另外一个职工领导。

**2.E-R图**

**最常用的数据模型：实体联系模型**

a.实体型用矩形表示

b.属性用椭圆形表示，用无向边同实体型连接起来

c.联系用菱形表示，框内写联系名，并用无向边同有关实体型连接起来

**如果联系有属性，也要用无向边连接起来**

实体与属性的划分原则：**事物能作为属性对待的尽量作为属性对待**

作为属性不能再具有需要描述的性质、属性与其他实体不能具有联系。

E-R图的集成：

(1)合并E-R图：各子系统的E-R图存在三类冲突：属性冲突、命名冲突、结构冲突

(2)消除不必要的冗余

****

### 7.4逻辑结构设计

概念结构是独立于任何一种数据模型的信息结构，**独立于硬件设备和DBMS**，逻辑结构设计的任务就是把概念结构设计阶段设计好的E-R图转换为与选用DBMS所支持的数据模型相符合的逻辑结构。

**E-R图转关系模型：**

1.一个实体型就是一个关系模式，关系的属性就是实体的属性，关系的码就是实体的码。

2.实体型的联系转换

1：1联系可以转换为一个独立的关系模式，也可以与任意一端对应得关系模式合并。

1：n联系可以转换为一个独立的关系模式，也可以与**n端**对应的关系模式合并。

n：m联系转换为一个关系模式，与**该联系相连的各实体的码以及联系本身的属性**均转换为关系的属性，各实体的码组成关系的码或者关系码的一部分。

具有相同码的关系模式可合并。

****

### 7.5物理结构设计

物理设计主要分为两步：确定数据库的物理结构、对物理结构进行评价

内容主要包括：关系模式选择存取方法、设计关系，索引等数据库文件的物理存储结构。

****

## 第八章 数据库编程

SQL编程访问和管理数据库中数据的方式：嵌入式SQL、过程化SQL、存储过程和函数、开放数据库连接/ODBC、OLE DB、JDBC。

### 8.1嵌入式SQL

嵌入式SQL是将SQL语句嵌入程序设计语言中，被嵌入的程序设计语言，如C,C++等成为宿主语言，简称主语言。

SQL语句负责操作数据库，高级语言负责控制逻辑流程。

游标：系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋值给主变量，交由主语言进一步处理。

### 8.2过程化SQL

过程化SQL程序的基本结构是块，每个块完成一个逻辑操作。

### 8.3存储过程和函数

过程化SQL块主要有两种类型：匿名块、命名块，上面是匿名块，每次执行时都要编译，不能被存储到数据库中，也不能不其他过程化SQL块调用。

过程和函数都是命名块，它们被编译后保存到数据库服务器中，成为持久性存储模块，可以被反复调用，运行速度较快。

**存储过程的优点：**

1.运行效率高

2.存储过程降低了客户机与服务器之间的通信量。

3.方便实施企业规则。

```sql
1.创建过程
create or replace procedure 过程名(参数)
as <过程化SQL块>;
2.执行过程
call/perform procedure 过程名(参数);
3.修改
alter procedure 过程名1 rename to 过程名2
drop procedure 过程名()
```

函数同存储过程的不同之处在于必须指定返回的类型

```sql
create or replace function 函数名(参数) returns <类型>
as <过程化SQL块>;
```

### ODBC、OLE DB、JDBC编写的应用的可移植性好，能同时访问不同的数据库，共享多个数据资源。

****

## 第九章 关系查询处理和查询优化

### 9.1 关系数据库系统的查询处理

查询处理是关系数据库系统执行查询语句的过程，其任务是把用户提交给关系数据库管理系统的查询语句转换为高效的查询执行计划。

**查询处理步骤：**

**查询分析**：对查询语句进行扫描，语法分析和词法分析。

**查询检查**：对合法的查询语句进行语义检查，即根据数据字典中有关的模式定义检查语句中的数据库对象，如关系名，属性名是否存在和有效。

**查询优化：每个查询都有许多可选择的执行策略和操作算法，查询优化就是选择一个高效执行的查询处理策略。**一般可分为物理优化和代数优化。

**查询执行**：由代码生成器生成执行查询计划的代码，然后加以执行，回送查询结果。

实现操作操作的算法：

1.选择操作实现

简单的全表扫描法、索引扫描算法

2.连接操作实现

嵌套循环算法、排序-合并算法、索引连接算法、hash join算法

### 9.2 查询优化

优点：用户不用考虑如何最好地表达查询以获得较高的效率，而且在于系统可以比用户程序的优化做的更好。

****

## 第10章 数据库恢复技术

### 10.1 事务的基本概念

**事务是一系列的数据库操作，是数据库应用程序的基本逻辑单元，是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做。**

```sql
SQL定义事务的三条语句：
BEGIN TRANSACTION;
COMMIT;//提交事务的所有操作，具体地说就是将事务中所有对数据库的更新写回到磁盘上的物理数据库中去。
ROLLBACK;//表示回滚，事务运行时发生某种故障，事务不能继续执行，系统将事务中对数据库的所有以完成的操作都全部撤销，回滚到事务开始时的状态
```

**事务的4个特性(ACID)：原子性、一致性、隔离性、持续性**

### 10.3故障的种类

**1.事务内部的故障**

非预期的，不能由应用程序处理的。

**事务撤销/UNDO：撤销事务已作出的任何对数据库的修改，使用该事务好像没有启动一样。**

**2.系统故障**

指造成系统停止运转的任何事件，使得系统要重新启动，例如CPU故障、OS故障、DBMS故障、系统断电。

**重做/REDO**:将已提交的结果重新写入数据库。

**3.介质故障**

硬故障，指外存故障，如磁盘损坏、磁头碰撞、磁场干扰。

**4.计算机病毒**

各类故障对数据库的影响两种可能性：数据库本身被破坏、数据库未被破坏，但数据可能不正确。

### 10.4 恢复的实现技术

**恢复的基本原理：冗余**

**1.数据转储**

转储即数据库管理员定期将整个数据库复制到磁盘、磁带或其他存储介质的过程。这些备用数据称为**后备副本**。

转储方式：

静态转储、动态转储(必须建立日志文件)

转储方式：

海量转储、增量转储

**2.登记日志文件**

1.日志文件的格式和内容

日志文件用来记录数据库的更新操作的文件。日志文件的两种格式：以记录为单位的日志文件和以数据块为单位的日志文件。

2.日志文件的作用

a.事务故障恢复和系统故障恢复必须使用日志文件

b.动态转储，需要将后备副本和日志文件结合起来才能有效的恢复数据库。

c.静态转储也可以建立日志文件。

3.登记日志文件

两个原则：登记的次序严格按并发事务执行的时间次序、必须先写日志文件，后写数据库。

### 10.5 恢复策略

**1.事务故障的恢复**

事务故障是指事务在运行至正常终止点前被终止，恢复应利用日志文件撤销此事务已对数据库进行的修改，由系统自动完成。

恢复步骤：---**撤销**

1.反向扫描日志文件，查找该事务的更新操作

2.对该事务的更新操作进行逆操作

3.继续方向扫描日志文件，查找该事务的其他更新操作，并作同样处理。

4.如此处理下去，直到读到此事务的开始标记。

**2.系统故障的恢复**

恢复操作就是要撤销故障发生时未完成的事务，重做已完成的事务。

恢复步骤：

1.正向扫描日志文件，找到在故障前已提交的事务，将其加入REDO-LIST，同时找到故障发生时尚未完成的事务，加入UNDO-LIST。

2.对撤销队列的各个事务进行UNDO处理

反向扫描日志文件

3.对重做队列的各个事务进行REDO处理

正向扫描日志文件

**3.介质故障的恢复**

物理数据和日志文件都被毁坏，只有重装数据库，然后重做已完成的事务。

装入最新后备副本-->装入相应的日志文件副本，重做已完成事务。

### 10.6 具有检查点的恢复技术

在日志文件中增加一类新的记录---检查点记录，增加一个重新开始文件，并让子系统在登陆日志文件期间动态维护日志。

**检查点记录的内容：**

建立检查点时刻所有正在执行的事务清单、这些事务最近一个日志记录的地址。

**重新开始文件**用来记录各个检查点记录在日志文件中的地址。

系统使用检查点方法进行恢复的步骤：

**故障点之前有提交则重做，否则撤销**

**1.**从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录。

**2.**由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST

这里建立两个事务队列：

1)UNDO-LIST：需要执行UNDO操作的事务集合

2)REDO-LIST：需要执行REDO操作的事务集合

把ACTIVE-LIST集合暂时放入UNDO-LIST,REDO队列为空

**3.**从检查点开始正向扫描日志文件

1)如有新开始的事务Ti，把Ti暂时放入UNDO-LIST队列

2)如有提交的事务Tj，把Tj从UNDO-LIST队列移到REDO-LIST队列，直到日志文件结束

**4.**对UNDO-LIST队列每个事务执行UNDO操作，对REDO-LIST队列每个事务执行REDO操作。

****

## 第11章 并发控制

### 11.1并发控制概述

事务是并发控制的基本单位，产生三类数据的不一致性主要原因是并发操作破坏了事务的**隔离性**。

**三种不一致性造成原因：**

**1.丢失修改**

两个事务T1和T2读入同一数据修改，T2提交结果破坏了T1提交结果，导致T1 的修改被丢失。

**2.不可重复读**

事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次的读取结果。

1）T2修改对其进行了修改

2）T2删除了其中部分记录

3）T2插入了一些记录

**3.读“脏数据”**

指事务T1修改某一数据并将其修会磁盘，T2读取同一数据后，T1由于某种原因被撤销，这是T1修改过的数据恢复原值，T2读到的数据就与数据库中的不一致，则T2读到的数据就为脏数据。

并发控制的主要技术：**封锁/基本方法**、时间戳、乐观控制法、多版本并发控制

### 11.2 封锁

封锁就是事务T在对某个数据对象例如表等操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定控制，在事务T释放它的锁之前，其他事务就不能更新此对象。

封锁的两种基本类型：排它锁/写锁/x锁、共享锁/读锁/s锁

加上排它锁之后其他事务不能加锁，也不能读写。

加上共享锁之后，其他事务可以加读锁，不能加X锁，只能读，不能修改。

### 11.3封锁协议

**1.一级封锁协议**

事务T在修改数据R之前必须先对其加X锁，直到**事务结束**才释放。

可防止丢失修改。

**2.二级封锁协议**

在一级封锁协议的基础上增加事务T在读取数据 R之前必须先对其加S锁，**读完后**即可释放S锁。

可防止丢失修改、读脏数据。

**3.三级封锁协议**

在一级封锁协议的基础上增加事务T在读取数据R之前必须先对其加S锁，**事务结束之后**再释放。

可防止丢失修改、读脏数据、不可重复读。

三种协议的主要区别在于什么操作需要申请封锁，什么时候释放锁。

**11.4活锁和死锁**

1.活锁

采用先来先服务策略避免活锁。

2.死锁

死锁的预防：一次封锁、顺序封锁

死锁的诊断和解除：超时法、等待图法。
