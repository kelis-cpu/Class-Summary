---
typora-root-url: D:\App\Typora\images

---

# 第一章 操作系统引论

## 1.1操作系统的概念、功能和目标

### 1.OS的概念

![image-20210809161749592](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210809161749592.png)

OS：指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以供用户和其他软件方便的接口和环境，是计算机系统中最基本的系统软件。

### 2.OS的功能和目标

**1.功能**

**a.作为系统资源的管理者**：处理机管理、存储器管理、文件管理、设备管理--目标：安全、高效

**b.作为用户和计算机硬件之间的接口**：命令接口(联/脱机命令接口)、程序接口、GUI--目标：方便用户使用

命令接口：允许用户直接使用，联机命令接口：用户说一句，系统做一句，**比如cmd等交互式命令接口**、脱机命令接口：用户说一堆，系统做一堆，**比如bat文件等批处理命令接口**

程序接口：允许/只能用户通过程序间接使用，由一组系统调用组成，**比如调用dll文件。**

GUI：Windows、ios的图形化操作界面

**c.作为最接近硬件的层次**：实现对硬件机器的拓展

![image-20210809163750447](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210809163750447.png)

## 1.2 OS的特征

### 1.并发

并发：两个或多个事件在同一时间间隔内发生，宏观上同时发生，微观上交替发生。--并行：两个或多个事件在同一时刻同时发生。

OS的并发性：计算机系统同时存在多个运行着的程序。

### 2.共享

即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。

互斥共享方式：一段时间内只允许一个进程访问该资源--QQ、vx视频对摄像头的使用。

同时共享方式：允许一个时间段内由多个进程“同时”对它们进行访问--QQ发送文件A，vx发送文件B，宏观上同时使用硬盘资源，微观上，两个进程交替访问硬盘。也有可能真正并行，同时播放游戏声音和音乐。

 **并发和共享互为存在条件。**

### 3.虚拟

是指把一个物理的实体变为若干个逻辑上的对应物，物理实体实际存在，逻辑上对应物是用户感受到的。

虚拟技术--空分复用--虚拟存储器技术、时分复用--虚拟处理器技术

### 4.异步

在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进。

**没有并发和共享，就谈不上虚拟和异步，因此并发和共享就是OS的最基本的两个特征。**

## 1.3 OS的发展和分类

### 1.手工阶段

缺点：用户独占全机、人机速度矛盾导致资源利用率极低

### 2.单道批处理系统

引入脱机输入/输出技术(用磁带完成)，并**监督程序**--OS的雏形，负责控制作业的输入、输出。

优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升

缺点：内存中仅能有一道程序运行，只有该程序运行结束后才能调用下一道程序。**CPU有大量时间是在空闲等待I/O完成，资源利用率依然很低。**

### 3.多道批处理系统

**OS正式诞生，引入了中断技术，各程序并发执行。**

优点： 多道程序并发执行，共享计算机资源。

缺点：用户响应时间长，无人机交互功能。

为何多道批处理系统能使资源利用率大幅提升？

**不同设备可以真正并行运行，处理程序。**比如，输入、计算、输出设备。

### 4.分时操作系统

计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。

优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。

缺点：不能优先处理一些紧急任务。

### 5. 实时操作系统

主要优点：能够优先响应一些紧急任务，某些紧急任务不需要时间片排队。

在实时OS的控制下，计算机系统接收到外部信号后即时进行处理，并在严格的时限内处理完事件，具有及时性和可靠性。

硬实时系统:必须在严格的规定时间内完成处理--自动驾驶系统、导弹系统

软实时系统：能接受偶尔违反时间规定--12306订票系统

## 1.4 OS的运行机制与体系结构

指令：CPU能够识别、执行的最基本命令。

![image-20210809174516943](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210809174516943.png)

## 1.5 中断和异常

中断的诞生：为实现多道程序并发执行而引入的一种技术。

中断本质：发生中断就意味着需要OS介入，开展管理工作(CPU进入核心态)

**用户态、核心态之间的切换是如何实现的？**

用户态-->核心态是通过中断实现的，并且中断是唯一途径，通过执行特权指令，将程序状态字PSW的标志位设为用户态。

![image-20210809175931813](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210809175931813.png)

**外中断的处理过程：**

1.执行完每个指令后，CPU检查当前是否有外部中断信号

2.如果监测到外部中断信号，则需要保护被中断进程的CPU环境(如PSW、程序计数器PC、各种通用寄存器)

3.根据中断信号类型转入相应的中断处理程序

4.恢复原进程的CPU环境并退出中断处理，返回原进程继续往下执行。

## 1.6 系统调用

![image-20210809182838744](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210809182838744.png)

**OS为何提供系统调用功能？**

为了避免各进程随意使用各种共享资源，所以OS就提供了“系统调用”功能，用户进程要使用打印机这种共享资源，只能通过系统调用向OS发出请求，OS来对各个请求进行协调管理。

# 第二章 进程的描述与控制

## 2.1.1 进程的定义

### 1.进程的定义

程序段、数据段、PCB三部分组成了进程实体(进程映像)。一般情况下称进程实体为进程。**PCB是进程存在的唯一标志。**

进程可以有不同的定义：

1.进程是程序的一次执行过程。

2.进程是一个程序及其数据在处理机上顺序执行时所发生的活动。

3.进程是具有独立功能的程序在数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位。

**进程(静态)是进程实体(动态)的运行过程，是系统进行资源分配和调度的一个独立单位。**

### 2.进程的组成

![image-20210815162630081](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210815162630081.png)

### 3.进程的组织

![image-20210815162959467](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210815162959467.png)

### 4.进程的特征

![image-20210815163207713](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210815163207713.png)

## 2.1.2 进程的状态及转换

![image-20210815165312849](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210815165312849.png)

## 2.1.3 进程控制

进程的控制：对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。

 ![image-20210815170849716](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210815170849716.png)

原语所做的三类事情：

1.更新PCB中的信息(修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)

a.所有的进程控制原语一定都会修改进程状态标志

b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境

c.某进程开始运行前必然需先恢复其运行环境

2.将PCB插入到合适的队列

3.分配、回收资源

## 2.1.4 进程通信

一个进程不能直接访问另一个进程的地址空间。

![image-20210815172147448](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210815172147448.png)

1.共享存储

两个进程对共享空间的访问必须是互斥的

a.基于数据结构的共享

比如共享空间只能放一个长度为10的数组 ，速度较慢，限制多

b.基于存储区的共享

OS画出一块共享存储区

2.管道通信

内存中开辟的一个大小固定的缓存区，**只能采用半双工通信**，各进程互斥地访问管道。

**未写满，不允许读、没读空，不允许写**，读进程最多只能有一个。

写满不能再写，读空不能再读。

3.消息传递

进程简单的数据交换以格式化的消息为单位，进程通过OS提供的“发送、接收”两个原语进行数据交换，包括**直接通信方式**(消息直接挂到接收方的消息队列)和**间接通信方式**(消息先发送到中间体/信箱)。

### 2.1.5线程的概念

**为何要引入线程？**

传统的进程只能串行执行一系列程序，为增加并发度，引入线程。

引入线程带来的变化：

![image-20210816103758928](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210816103758928.png)

**OS只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。**

![image-20210816105258830](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210816105258830.png)

### 2.2.1 处理机调度的概念、层次

处理机调度就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。

**调度的三个层次：**

1.作业调度--外存与内存之间的调度

主要指调入问题，按一定原则从外存上处于后备队列的作业中挑选一个或多个作业，分配内存等必要资源，并**建立相应的进程**，以使它们获得竞争处理及的权利。

2.中级调度--内存调度--将哪个处于挂起状态的进程重新调入内存

将暂时不能运行的进程调至外存等待，等它具有运行条件且内存稍有空闲时，再重新调入内存

**七状态模型：**

![image-20210816111039363](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210816111039363.png)

3.进程调度

OS中最基本的一种调度，一般os中都配置进程调度。

![image-20210816111416587](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210816111416587.png)

### 2.2.2 进程调度的时机、切换与过程调度方式

**一.进程调度的时机**

![image-20210816112411703](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210816112411703.png)

**二.进程的调度方式**

非剥夺调度方式/非抢占方式--只允许进程主动放弃处理及、剥夺调度方式/抢占方式

**三.进程的切换与过程**

进程切换的过程主要完成了：

1.对原来运行进程各种数据的保存

2.对新的进程各种数据的恢复(程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般都保存在PCB中)

### 2.2.3 调度算法的评价指标

**1.CPU利用率**

利用率=忙碌时间/总时间

**2.系统吞吐量--单位时间内完成的作业数量**

**3.周转时间**

指：作业从被提交给系统开始，到作业完成为止的这段时间间隔

包括：作业在外存后备队列上等待作业调度的时间、进程在就绪队列上等待进程调度的时间、进程在CPU上执行的时间、进程等待I/O操作的时间

**带权周转时间=作业周转时间/作业实际运行时间=(作业完成时间-作业提交时间)/作业实际运行的时间**

**4.等待时间**

指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低

**等待时间=周转时间-运行时间=周转时间-运行时间-I/O操作时间**

**5.响应时间**

指用户提交请求到首次产生响应所用的时间

### 2.2.4 FCFS、SJF、HRRN调度算法

**1.FCFS**

 ![image-20210816120024311](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210816120024311.png)

**2.SJF**

 最短剩余时间优先算法/SRTN:每当有进程加入就绪改变时就需要调度，如果到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，一个进程完成时也需要调度。

![image-20210816121940503](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210816121940503.png)

**3.高响应比优先算法**

![image-20210816122752294](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210816122752294.png)

**注：**

以上这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，不关心“响应时间“，也不区分任务的紧急程度，交互性很差，一般适用于**早期的批处理系统**。

**4.时间片轮转调度算法**

时间片太大，RR退化为FCFS，并且会增大进程响应时间。

时间片太小，导致进程切换过于频繁，系统花大量的时间来处理进程切换。

一般来说时间片的设计，进程切换占比不超过1%

![image-20210816171808608](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210816171808608.png)

**5.优先级调度算法**

**合理地设置各类进程的优先级？**

系统进程>用户进程、前台进程>后台进程、OS更偏好I/O型进程(I/O设备和CPU可以并行工作，如果优先I/O繁忙型进程优先运行的话，则越可能让I/O设备尽早投入工作，则资源利用率、系统吞吐量都会得到提升)

**采用动态优先级，什么时候应该调整？**

可以从追求公平、提高资源利用率等角度来考虑，

1、如果某进程在就绪队列中等待了很长一断时间，则可适当提升其优先级

2、如果某进程占用处理机运行了很长时间，则可适当降低其优先级

3、如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级

![image-20210816173228742](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210816173228742.png)

**6.多级反馈队列调度算法**

![image-20210816174312302](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210816174312302.png)

### 2.3.1 进程同步、互斥

![image-20210816211142377](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210816211142377.png)

### 2.3.2 进程互斥的软件实现方法

 **1.单标志法**

算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。

**违背了”空闲让进“原则**

**2.双标志先检查法**

算法思想：设置一个布尔型数组flag，数组中各个元素用来标记各进程进入临界区的意愿，比如flag[0]=true意味着0号进程现在想要进入临界区。

**违背了忙则等待原则**，因为进入去的检查和上锁两个处理不是一气呵成的，检查后，上锁前可能发送进程切换。

**3.双标志后检查法**

算法思想：前一个算法是先检查，后上锁--->先上锁，后检查

**解决了忙则等待，但是违背了”空闲让进“，”有限等待“原则，会因各进程长期无法访问临界资源的而产生”饥饿现象“**

**4.Peterson算法**

**遵循了空闲让进，忙则等待，有限等待，但是未遵循让权等待。**

### 2.3.2 进程互斥的硬件实现方法

**1.中断屏蔽方法**

使用开/关中断指令实现

优点：简单高效

缺点：只适用于单处理机，只适用于操作系统内核进程

**2.TestAndSet指令**

简称TS指令或TSL指令，用硬件实现，执行的过程不允许被中断，只能一气呵成。

```c
bool TestAndSet(bool *lock){
    bool old;
    old=*lock;
    *lock=true;
    return old;
}
//使用TSL指令实现互斥的算法逻辑
while(TestAndSet(&lock));//上锁并检查
临界区代码;
lock=false;//解锁
剩余区代码;
```

优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞，适合用于多处理机环境

缺点：不满足”让权等待“原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致”忙等“。

**3.Swap指令**

类似TSL指令

### 2.3.4 信号量机制

**1.整形信号量--不满足让权等待**

用一个整数型的变量作为信号量，用来表示系统中某种资源的数量

```c
int S=1;//初始化整形信号量S，表示当前系统中可用的资源数
void wait(int S){
    while(S<=0);
    S=S-1;
}
void signal(int S){
    S+=1;
}
```

**2.记录型信号量**

**解决了“忙等”问题**

```c
//记录型信号量的定义
typedef struct{
    int value; //剩余资源数
    struct process *L; //等待队列
}semaphore;
void wait(semaphore S){
    S.value--;
    if(S.value<0){
        block(S.L);
        //如果剩余资源数不够，使用block原语使进程从运行态进入到阻塞态，并挂到信号量S的等待队列中
    }
}
void signal(semaphore S){
    S.value++;
    if(S.value<=0){
        wakeup(S.L);
        //释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态
    }
}
```

### 2.3.5 信号量机制实现进程互斥、同步

**1.实现互斥**

1.分析并发进程的关键活动，划定临界区(如：对临界资源打印机的访问就应放在临界区)

2.**设置互斥信号量mutex，初值为1**

3.在临界区之前执行P(mutex)

4.在临界区之后执行V(mutex)

**注：不同的临界资源需要设置不同的互斥信号量、P/V操作必须成对出现**

```c
semaphore mutex=1;//初始化信号量
P1(){
    P(mutex);
        临界区代码；
    V(mutex);
}
P2(){
    P(mutex)
        临界区代码；
    V(mutex)
}
```

**2.实现进程同步--让本来异步并发的进程互相配合，有序推进**

1.分析什么地方需要实现”同步关系“，即必须保证”一前一后“执行的两个操作

2.设置同步信号量S,初始化为0

3.**在”前操作”之后执行V(S)**

4.**在“后操作”之前执行P(S)**

```c
semaphore S=0;
P1(){
    代码1;
    代码2;
    V(S);
    代码3;
}
P2(){
    P(S);
    代码4;
    代码5;
    代码6;
}
```

**3.实现前驱关系**

1.为每一对前驱关系各设置一个同步变量

2.在"前操作"之后对相应的同步变量执行V操作

3.在“后操作”之前对相应的同步变量执行P操作

### 2.3.6 生产者-消费者问题

![image-20210817110416699](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210817110416699.png)

**1.关系分析。找出题目中描述的各个进程，分析它们之间的同步关系、互斥关系**

**2.整理思路。根据各进程的操作流程确定P、V操作的大致顺序**

**3.设置信号量。设置需要的信号量，并根据题目条件确定信号量初值**

```c
semaphore mutex=1;//互斥信号量
semaphore empty=n;//空缓冲区数量
semaphore full=0;//产品数量
producer(){
    生产一个产品;
    P(empty);
    P(mutex);
    将产品放入缓存区;
    V(empty);
    V(mutex);
}
consumer(){
    P(full);
    P(mutex);
    从缓冲区取出一个产品;
    V(mutex);
    V(full);
    使用产品;
}
//注：1.实现互斥和同步的两个P操作的先后顺序不能跌倒，否则可能产生死锁，先同步，再互斥
//2.使用产品/生产产品放在临界区会降低进程的并发度
```

### 2.3.7 多生产者-多消费者

```c
semaphore apple=0;
semaphore orange=0;
semaphore plate=1;
semaphore mutex=1;
dad(){
    削苹果;
    P(plate);
    P(mutex);
    放入苹果;
    V(mutex);
    V(apple);
}
mom(){
    剥橘子;
    P(plate);
    P(mutex);
    放入橘子;
    V(mutex);
    V(orange);
}
daugther(){
    P(orange);
    P(mutex);
    拿橘子;
    V(mutex);
    V(plate);
}
son(){
    P(apple);
    P(mutex);
    拿苹果;
    V(mutex);
    V(plate);
}
//注：可以不使用互斥信号量，因为缓冲区大小为1，在任何时刻，apple，orange，plate三个同步信号量中最多只有一个是1.因此在任何时刻，最多只有一个进程的P操作 不会被阻塞，并顺利地进入临界区。如果plate=2，会出现覆盖写问题。
```

### 2.3.8 吸烟者问题

```c
semaphore finish=0;
semaphore offer0=0;
semaphore offer1=0;
semaphore offer2=0;
provider(){
    while(1){
        if(i==0){
            提供组合一;
            V(offer0)
        }else if(i==1){
            提供组合二;
            V(offer1);
        }else{
            提供组合三;
            V(offer2);
        }
        i=(i+1)%3;
        P(finish);
    }
}
P0(){
    P(offer0);
    抽烟;
    V(finish);
}
```

### 2.3.9 读者-写者问题

```c
//读者优先--可能产生写者饥饿问题
semaphore rw=1;//用于实现文件的互斥访问
semaphore mutex=1;//设置互斥变量，互斥访问count
int count=0;//记录正在读文件的数量
writer(){
    while(1){
        P(rw);
    	写文件;
    	V(rw);
    }
}
reader(){
    while(1){
        P(mutex);
    	if(count==0)
        	P(rw);
    	count++;
    	V(mutex);
    	写文件;
    	P(mutex);
    	count--;
    	if(count==0)
       	 	V(rw);//最后一个读进程负责“解锁”
  		V(mutex);    
    }
}
//写者优先
semaphore mutex=1;
semaphore w=1;//用于实现写优先
semaphore rw=1;
int count=0;
writer(){
    while(1){
       P(w);
       P(rw);
        写文件;
       V(w);
       V(rw);
    }
}
reader(){
    P(w);
    P(mutex);
    if(count==0)
        P(rw);
    count++;
    V(mutex);
    V(w);
    读文件;
    P(mutex);
    count--;
    if(count==0)
        V(rw);
    V(mutex);
}
```

### 2.3.10 哲学家进餐问题

**如何防止死锁发生？**

1.最多允许四个哲学家同时进餐

2.要求奇数号哲学家先拿左边筷子，然后再拿右边筷子，偶数号哲学家相反。

3.仅当一个哲学家左右两支筷子都可以使用时，才拿起筷子。

```c
semaphore chopstick[5]={1,1,1,1,1};
semaphore mutex=1;//互斥地取筷子
Pi(){
    while(1){
        P(mutex);
        P(chopsticks[i]);
        P(chopsticks[(i+1)%5]);
        V(mutex);
        进餐;
        V(chopsticks[i]);
        V(chopsticks[(i+1)%5]);
    }
}
```

### 2.3.11 管程

![image-20210817174713919](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210817174713919.png)

### 2.4.1 死锁的概念

1.死锁、饥饿、死循环的区别

死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。

饥饿：由于长期得不到资源，某进程无法向前推进的现象。

死循环：某进程执行过程中一直跳不出某个循环的现象。

![image-20210817180329692](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210817180329692.png)

2.死锁产生的必要条件

**a.互斥条件**

只有对必须互斥使用的资源的争抢才会导致死锁

**b.不剥夺条件**

进程所获得资源在未使用之前，不能由其他进程强行夺走。

**c.请求和保持条件**

进程至少保持一个资源，但又提出新的资源请求

**d.循环等待条件**

发生死锁一定有循环等待，但是发生循环等待未必死锁。如果同类资源数大于1，则即使有循环等待，也不会发生死锁。

**3.什么时候发生死锁**

1.对系统资源的竞争

2.进程推进顺序非法

3.信号量使用不当

**总之，对不可剥夺资源分配不合理，可能发生死锁**

**4.死锁的处理策略**

1.预防死锁--破坏死锁产生的四个必要条件

2.避免死锁--避免系统进入不安全状态

3.死锁的检查和解除--允许死锁发生，系统负载检查出死锁并解除

### 2.4.2 预防死锁

**1.破坏互斥条件**

把只能互斥使用的资源改造成允许共享使用，比如**SPOOLing技术**，OS可以采用SPOOLing技术把独占设备在逻辑上改成共享设备。

缺点：不是所有资源都可以改造成可共享使用的资源，并且为了系统安全，还必须保护这种互斥性。

**2.破坏不可剥夺条件**

方案一：当某个进程请求新的资源得不到满足时，必须立即释放保持的所有资源

方案二：当某个进程需要的资源被其他进程所占有的时候，可由OS协助，将想要的资源强行剥夺。

缺点：实现起来比较复杂、释放已获得的资源可能造成前一段工作的失效(这种方法只适用于已保存和恢复状态的资源，如CPU)、反复申请和释放资源会增加系统开销，降低系统吞吐量、如采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都要放弃，以后再重新申请，会导致进程饥饿。

**3.破坏请求和保持条件**

a.静态分配，在进程运行前一次申请完所需全部资源。

缺点：有些资源可能只需很短时间，因此如果进程的整个运行期间一直保持所有资源，就会造成严重的资源浪费，资源利用率极低，另外也可能导致进程饥饿

**4.破坏循环等待条件**

采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。

缺点：不方便新增设备，因为可能需要重新分配所有编号、进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费、必须按次序申请资源，用户编程麻烦

### 2.4.3 避免死锁--银行家算法

如果系统出于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁。

![image-20210817210605877](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210817210605877.png)

### 2.4.4 检测和解除死锁

死锁定理：如果某时刻的资源分配图是不可完全简化的，那么此时系统死锁。

![image-20210817212125290](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210817212125290.png)

# 第三章 存储器管理与虚拟存储器

### 3.1.1 内存的基础知识

内存：存放数据的硬件，程序执行前需先放到内存中才能被CPU处理。

**写程序到程序运行：**

编辑-->编译-->链接-->装入

编译：由编译程序将用户源代码编译成若干个目标模块(高级语言-->机器语言)

链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块。

装入：由装入程序将模块装入内存运行。

**装入三种方式：**

1.绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。

2.静态重定位：装入时对地址进行“重定位”，将逻辑地址变换为物理地址(装入时一次完成)

3.动态重定位：装入后依然时逻辑地址，把地址转换推迟到程序真正要执行时才进行，**需要一个重定位寄存器的支持**

**链接的三种方式：**

静态链接、装入时动态链接、运行时动态链接

### 3.1.2 内存管理的概念

**OS对内存的管理：**

1.负责内存空间的分配与回收

2.OS需提供某种技术(虚拟技术)从逻辑上对内存空间进行扩充

3.需提供地址转换功能，负责程序的逻辑地址与物理地址的转换

4.提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰

**内存保护的两种方法：**

1.在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。

2.采用重定位寄存器(又称基址寄存器--存放进程的起始物理地址)和界地址寄存器(又称限长寄存器--存放进程的最大逻辑地址)进行越界检查。

### 3.1.3 覆盖与交换--内存空间的扩充技术

**1.覆盖技术**

![image-20210818101540617](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210818101540617.png)

**2.交换技术**

a.应该在外存的什么位置保存被换出进程？

具有对换功能的OS中，通常把磁盘空间分为文件区--追求存储空间利用率，采用离散分配方式和对换区--追求换入换出速度，采用连续分配方式。

b.什么时候应该交换？

通常在许多进程运行时进程发生缺页时进行，而系统负荷降低就暂停。

c.换出哪些进程？

可优先换出阻塞进程；可换出优先级低的进程

**PCB会常驻内存，不会被换出**

### 3.1.4 连续分配管理方式--内存空间的分配与回收技术

**1.单一连续分配**

内存分为系统区和用户区，内存中只能有一道用户程序，用户程序独占整个用户区

优点：实现简单；无外部碎片；不一定需要内存保护；可采用覆盖技术扩充内存

缺点：只能用于单用户、单任务的操作系统；有内部碎片，存储器利用率极低

**2.固定分区分配**

分区大小相等、分区大小不相等

优点：实现简单、无外部碎片

缺点：当用户程序过大时，可能所有分区都不能满足需求，此时不得不采用覆盖技术来解决，这又会降低性能、会产生内部碎片，内存利用率极低

**3.动态分区分配**

**1.**系统使用什么数据结构记录内存的使用情况？

a.空闲分区表

b.空闲分区链

![image-20210818104956234](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210818104956234.png)

**2.**当很多空闲分区满足需求时，应选择哪个分区进行分配？

**动态分区分配算法**

**3.**如何进行分区的分配与回收?

**回收：相邻空闲分区要合并**

**可通过紧凑技术来解决外部碎片，紧凑之后需要修改进程起始地址**

### 3.1.5 动态分区分配算法

![image-20210818111251152](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210818111251152.png)

### 3.1.6 基本分页存储管理的基本概念--非连续分配管理方式

**基本分页存储管理的思想**：把内存分为一个个相等的小分区，再按照分区把进程拆分为一个个小部分。

![image-20210818120118211](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210818120118211.png)

### 3.1.7 基本地址变换机构--基本分页存储管理的地址变换机构

![image-20210818122813326](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210818122813326.png)



### 3.1.8 具有快表的地址变换机构

**1.局部性原理**

**时间局部性**：如果执行了程序中的某条指令，那么不久之后很可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。--因为程序中存在大量的循环

**空间局部性**：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。--因为很多数据和指令在内存中都是连续存放的。

**2.快表**

是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程--**页表的一部分副本**。

![image-20210818155701524](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210818155701524.png)

### 3.1.9 两级页表

![image-20210818163458565](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210818163458565.png)

### 3.1.10 基本分段存储管理方式

**与分页最大的区别就是--离散分配时所分配地址空间的基本单位不同**

![image-20210818165241797](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210818165241797.png)

**分段、分页管理的对比:**

**1.**

页是信息的物理单位，分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户不可见。

段是信息的逻辑单位，分段的只要目的是更好地满足用户需求，一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。

**页的大小由系统决定，段的长度决定于用户编写的程序**

**2.**

分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。

分段的用户进程是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。

**3.**

分段比分页更容易实现信息的共享个保护。因为分页可能将不能共享的代码和能共享的代码划分到同一个页面。

**4.**

分段与分页都需要访问两次内存。

### 3.1.11 段页式管理方式

![image-20210818173926174](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210818173926174.png)

### 3.2.1 虚拟内存的基本概念--内存空间的扩充

**1.传统存储管理方式的特征、缺点**

**很多暂时用不到的数据也会长期占用内存，导致内存利用率不高**

**一次性：**作业必须一次性全部装入内存后才能运行。导致大作业不能全部装入内存，大作业就无法运行、大量作业要求运行时，内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。

**驻留性：**一旦作业装入内存，就会一直驻留在内存中，直至作业运行结束。

**2.高速缓冲技术的思想**

将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放到更低速存储器中。

**易混知识点：**

虚拟内存的最大容量：由计算机的地址结构决定(cpu寻址范围)

虚拟内存的实际容量=min(内存+外存容量之和，cpu寻址范围)

**3.虚拟内存的主要特征**

**多次性：**无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存

**对换性：**在作业运行时无需一直常驻内存，而是允许在作业允许过程中，将作业换入、换出

**虚拟性：**在逻辑上扩充了内存的容量，使用户看到的容量远大于实际的容量

**4.如何实现虚拟内存技术**

虚拟内存的实现建立在离散分配的内存管理方式基础上。

![image-20210818180410910](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210818180410910.png)

### 3.2.2 请求分页管理方式

**1.页表机制**

![image-20210818195250939](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210818195250939.png)

**2.缺页中断机构**

![image-20210818195536516](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210818195536516.png)

**一条指令执行过程中，可能出现多次缺页中断**

**3.地址转换机构**

![image-20210818200432725](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210818200432725.png)

### 3.2.3 页面置换算法

页面的换入、换出需要磁盘I/O，会有较大的开销，因此好的页面置换算法应该追求**更少的缺页率。**

**1.最佳置换算法OPT**

每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面。

**缺页时未必发生页面置换，若还有可用的空闲内存块，就不用进行页面置换。**

OS无法提前预判页面访问序列，因此OPT无法实现。

**2.先进先出置换算法FIFO**

每次选择淘汰的页面事最早进入内存的页面

实现方法：把调入内存的页面根据调入的先后顺序排列成一个队列。**队列的最大长度为系统分配给进程的内存块**

**Belady异常：**当为进程分配的物理块数增大时，缺页次数不减反增的现象。

只有FIFO会产生Belady异常，FIFO虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也可能最经常被访问。因此算法性能差。

**3.最近最久未使用置换算法LRU**

每次淘汰最近最久未使用的页面

实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次以来被访问以来所经历的时间t。

性能好，但是实现困难，开销大--需要专门的硬件支持。

**4.时钟置换算法CLOCK/NRU**

![image-20210818203924625](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210818203924625.png)

### 3.2.4 页面分配策略

![image-20210818210100083](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210818210100083.png)

# 第四章 文件管理

### 4.1.1 初识文件管理

![image-20210818213402598](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210818213402598.png)

### 4.1.2 文件的逻辑结构

![image-20210819103247437](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210819103247437.png)

### 4.1.3 文件目录

![image-20210819110731921](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210819110731921.png)

**使用“当前目录”和“相对路径”之后，从当前路径出发，只需查询内存中的目录表，即可知道查询目录表的存放位置，再从外存调入该目录，减少了磁盘I/O次数。**

### 4.1.4 文件的物理结构

![image-20210819120756706](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210819120756706.png)

### 4.1.5 文件存储空间管理

![image-20210819170633006](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210819170633006.png)

### 4.1.6 文件的基本操作

**1.创建文件--create系统调用**

a.在外存中找到文件所需的空间(利用4.1.5中的方法)

b.根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。

**2.删除文件--delete系统调用**

a.根据文件存放路径找到相应的目录文件，从目录中找到文件对应的目录项。

b.根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块。

c.从目录表中删除文件对应的目录项。

**3.打开文件--open系统调用**

a.根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项，并检查该用户是否有指定的操作权限

b.将目录项复制到内存中的“打开文件表”中，并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。

**4.关闭文件--close系统调用**

a.将进程的打开文件表相应表项删除

b.回收分配给该文件的内存空间等系统资源

c.系统打开文件表的打开计数器count减1，若count=0，则删除对应的表项。

**5.读文件--read系统调用**

**需指明读哪个文件、读入多少数据、读入的数据放在内存中什么位置**。OS在处理read系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。

### 4.1.7 文件共享

![image-20210819174009341](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210819174009341.png)

### 4.1.8 文件保护

**1.口令保护**

为文件设置一个口令，用户请求时需提供“口令”。

优点：保存口令的空间开销不多，验证口令的时间开销很小

缺点：口令存放在系统内部(一般存放在文件对应的FCB或索引结点中)，不够安全。

**2.加密保护**

使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确解密。

eg.**异或加密**

优点：保密性强

缺点：加解密需要花费一定时间

**3.访问控制**

在每个文件的FCB或索引结点在增加一个ACL，该表中记录了各个用户可以对该文件执行的操作。

优点：实现灵活，可以实现复杂的文件保护功能

### 4.1.9 文件系统的层次结构

![image-20210819195729830](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210819195729830.png) 

**假设用户请求删除文件“D:/工作目录/test.txt”**

1.用户需要通过操作系统提供的接口发出上述请求--**用户接口**

2.由于用户提供的是文件的存放路径，因此需要OS一层一层地查找目录，找到对应的目录项--**文件目录系统**

3.不同的用户对文件有不同的操作权限，为保证安全，需要检查用户是否具有访问权限--**存取控制模块**

4.验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址--**逻辑文件系统与文件信息缓冲区**

5.知道了目标记录对应的逻辑地址之后，还需转换为实际的物理地址--**物理文件系统**

6.要删除这条记录，必定对磁盘设备发出请求--**设备管理程序模块**

7.删除记录后，会有一些盘块空闲，因此要将这些盘块回收--**辅助分配模块**

### 4.2.1 磁盘的结构

![image-20210819201222329](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210819201222329.png)

### 4.2.2 磁盘调度算法

**一次磁盘的读/写操作需要的时间=寻找时间/寻道时间Ts+延迟时间Tr+传输时间Tt**

Ts：在读/写数据前，将磁头移动到指定磁道所花的时间。

a.启动磁头臂时间s

b.移动磁头时间。设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。

**Ts=s+m*n**

Tr：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r(单位：转/秒、转/分)，则**Tr=1/(2r)**

Tt:从磁盘读出或写入数据所经历的时间，此次读/写的字节数为b，每个磁道的字节数为N，**Tt=b/(rN)**

**Tr与Tt与磁盘转速有关，且为线性相关，而转速是硬件固有属性，OS无法优化Tr、Tt，磁盘调度算法直接影响Ts。**

**1.FCFS**

根据进程请求访问磁盘的先后顺序进行调度

优点：公平，如果请求访问的磁道集中，算法性能还算过得去

缺点：大量进程竞争使用磁盘，请求访问磁道分散，寻道时间长

**2.SSTF**

优先处理的磁道是与当前磁道最近的磁道。--**贪心算法，眼前最优，总体未必最优。**

优点：性能好，平均寻道时间短

缺点：可能产生饥饿现象--**磁头可能在一个小区域来回移动**

**3.扫描算法SCAN**

只有磁头移动到最外侧磁道的时候才往内移动，移动到最内侧的时候才能往外移。

优点：**性能好，不会产生饥饿算法**

缺点：a.只有到达最边上的磁道时才能改变磁头移动方向、b.对各个位置磁道的响应频率不平均。

**解决a缺点方法：LOOK算法**

如果在磁头的移动方向上无别的请求，就可以立即改变磁头的移动方向

**解决b缺点方法：循环扫描算法/C-SCAN算法**

只有磁头朝某个特定方向移动时才能处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。

缺点：只有到达最边上磁道才改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘刺刀上。

**解决C-SCAN缺点：C-LOOK算法**

磁头移动到已经没有磁道访问请求，就可以让磁头返回，且磁头只需返回到磁道访问请求的位置即可。

### 4.2.3 减少磁盘延迟时间的方法

**1.交替编号**

让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。

![image-20210819205432907](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210819205432907.png)

**2.错位命名**

![image-20210819210025279](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210819210025279.png)

### 4.2.4 磁盘的管理

![image-20210819211104212](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210819211104212.png)

![image-20210819211205832](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210819211205832.png)

![image-20210819211002800](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210819211002800.png)

# 第五章 设备管理

### 5.1.1 I-O设备的概念和分类

![image-20210820093312709](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820093312709.png)

### 5.1.2 I-O控制器

**1. I/O控制器的功能**

a.接收和识别CPU发出的命令

如CPU发来的read/write命令，I/O控制器中会有相应的**控制寄存器**来存放命令和参数。

b.向CPU报告设备的状态

I/O控制器中会有相应的**状态寄存器**，用于记录I/O设备的当前状态，如：1表示空闲，0表示忙碌

c.数据交换

I/O控制器中会设置相应的**数据寄存器**。输出时，数据寄存器暂存CPU发来的数据，之后再由控制器传送设备。输入时，数据寄存器暂存设备发来的数据，之后CPU从数据就才南起中取走数据。

d.地址识别

类似于内存的地址，区分设备控制器中的各个寄存器，也为各寄存器设置一个特定的”地址“。I/O控制器通过CPU提供的”地址“来判断CPU要读/写哪个寄存器

![image-20210820095041421](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820095041421.png)

![image-20210820095335946](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820095335946.png)

### 5.1.3 I-O控制方式

**1.程序直接控制方式--轮询**

 ![image-20210820100529038](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820100529038.png)

**2.中断驱动方式--中断**

![image-20210820101014274](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820101014274.png)

**3. DMA-Direct Memory Access方式，直接存储器存取**

![image-20210820102116317](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820102116317.png)

![image-20210820102040581](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820102040581.png)

**4.通道控制方式**

![image-20210820102600591](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820102600591.png)

![image-20210820102528204](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820102528204.png)

### 5.1.4 I-O软件结构层次

![image-20210820104459222](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820104459222.png)

**设备驱动程序、中断处理程序直接与硬件接触**

### 5.1.5 I-O核心子系统

核心子系统：设备独立性软件、设备驱动程序、中断处理程序

![image-20210820105212927](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820105212927.png)

**I/O调度：用某种算法确定一个好的顺序来处理各个I/O请求**

如：磁盘调度、打印机都可以使用FCFS、SCAN、C-SCAN来确定I/O调度顺序。

**设备保护：设备看作是一种特殊的文件，每个设备都对应相应的FCB。当用户请求使用某个设备，系统根据FCB记录的信息来判断用户是否具有访问权限。**

### 5.1.6 假脱机技术

**脱机：脱离主机的控制进行输入/输出操作。**

![image-20210820110258311](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820110258311.png)

**SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备。**

**共享打印机原理：**

![image-20210820110939300](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820110939300.png)

### 5.1.7 设备的分配与回收

![image-20210820114000370](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820114000370.png)

**设备分配的步骤：**

![image-20210820114042084](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820114042084.png)

![image-20210820114057207](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820114057207.png)

### 5.1.8 缓冲区管理

![image-20210820114544972](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820114544972.png)

**1.单缓冲**

**OS在主存中为其分配一个缓冲区，当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须充满后才能把缓冲区数据传出。**

**采用单缓冲策略，处理一块数据平均耗时Max(C,T)+M**

![image-20210820115416619](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820115416619.png)

![image-20210820115321891](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820115321891.png)

**2.双缓冲**

![image-20210820120230489](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820120230489.png)

![image-20210820120147519](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820120147519.png)

**结论：采用双缓冲策略，处理一个数据块的平均耗时为Max(T,C+M)**

**3.循环缓冲区**

将多个大小相等的黄从前链接成一个队列

![image-20210820120652285](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820120652285.png)

**4.缓冲池**

![image-20210820121020724](C:\Users\kelise\AppData\Roaming\Typora\typora-user-images\image-20210820121020724.png)

